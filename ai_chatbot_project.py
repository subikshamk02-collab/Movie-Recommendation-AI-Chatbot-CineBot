# -*- coding: utf-8 -*-
"""AI_Chatbot_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GXxJAEQfb4WNA5bwr35vWlTT4jVMWYBm
"""

import kagglehub

# Download latest version
path = kagglehub.dataset_download("carolzhangdc/imdb-5000-movie-dataset")

print("Path to dataset files:", path)

import kagglehub
import pandas as pd
import zipfile

# Download IMDb 5000 Movies Dataset
path = kagglehub.dataset_download("carolzhangdc/imdb-5000-movie-dataset")
print("Dataset downloaded to:", path)

import os

dataset_path = "/root/.cache/kagglehub/datasets/carolzhangdc/imdb-5000-movie-dataset/versions/1"
print("Files in dataset folder:", os.listdir(dataset_path))

import pandas as pd

csv_file = dataset_path + "/movie_metadata.csv"  # replace with actual CSV name if different
df = pd.read_csv(csv_file)
df.head()

df.columns = df.columns.str.strip()
print(df.columns)

import pandas as pd

# Load dataset
df = pd.read_csv(dataset_path + "/movie_metadata.csv")

# Clean column names
df.columns = df.columns.str.strip()

# Create a simple movie info dictionary
movie_info = {}
for _, row in df.iterrows():
    title = str(row["movie_title"]).strip().lower()
    movie_info[title] = {
        "director": row["director_name"],
        "year": row["title_year"],
        "genre": row["genres"],
        "language": row["language"],
        "country": row["country"],
        "imdb_score": row["imdb_score"],
        "duration": row["duration"],
        "budget": row["budget"],
        "gross": row["gross"],
        "actors": [row["actor_1_name"], row["actor_2_name"], row["actor_3_name"]]
    }

# Check a sample
sample = list(movie_info.items())[0]
print("Sample entry:\n", sample)

import re

def chatbot_response(user_input):
    user_input = user_input.lower().strip()

    # Check for greetings
    greetings = ["hi", "hello", "hey", "hola", "good morning", "good evening"]
    if any(greet in user_input for greet in greetings):
        return "Hello! üé¨ I‚Äôm your MovieBot. Ask me about any movie ‚Äî its director, year, actors, genre, or IMDb rating!"

    # Check if the user wants to exit
    if "bye" in user_input or "exit" in user_input:
        return "Goodbye üëã! Hope you discovered something new about movies!"

    # Try to find a movie title in user query
    movie_found = None
    for title in movie_info.keys():
        if title in user_input:
            movie_found = title
            break

    if not movie_found:
        return "Hmm... I couldn‚Äôt find that movie. Please check the spelling or try another title üé•"

    movie = movie_info[movie_found]

    # Extract details from user query
    if re.search(r"director|who directed|made by", user_input):
        return f"The director of *{movie_found.title()}* is {movie['director']}."
    elif re.search(r"year|release|when", user_input):
        return f"*{movie_found.title()}* was released in {int(movie['year'])}."
    elif re.search(r"actor|actress|cast|stars", user_input):
        return f"The main actors in *{movie_found.title()}* are {', '.join(a for a in movie['actors'] if pd.notna(a))}."
    elif re.search(r"genre|type|kind", user_input):
        return f"The genre of *{movie_found.title()}* is {movie['genre']}."
    elif re.search(r"language", user_input):
        return f"The language of *{movie_found.title()}* is {movie['language']}."
    elif re.search(r"country", user_input):
        return f"*{movie_found.title()}* was produced in {movie['country']}."
    elif re.search(r"imdb|rating|score", user_input):
        return f"The IMDb rating of *{movie_found.title()}* is {movie['imdb_score']}."
    elif re.search(r"budget", user_input):
        return f"The budget of *{movie_found.title()}* was approximately ${movie['budget']}."
    elif re.search(r"gross|collection|box office", user_input):
        return f"*{movie_found.title()}* grossed about ${movie['gross']} at the box office."
    elif re.search(r"duration|long|length", user_input):
        return f"*{movie_found.title()}* runs for {movie['duration']} minutes."
    else:
        # Default general answer
        return (f"Here‚Äôs what I know about *{movie_found.title()}*:\n"
                f"üé¨ Director: {movie['director']}\n"
                f"üìÖ Year: {int(movie['year'])}\n"
                f"‚≠ê IMDb: {movie['imdb_score']}\n"
                f"üé≠ Genre: {movie['genre']}\n"
                f"üé§ Cast: {', '.join(a for a in movie['actors'] if pd.notna(a))}")

print("ü§ñ MovieBot is online! Type 'bye' or 'exit' to stop chatting.\n")

while True:
    user_input = input("You: ")
    response = chatbot_response(user_input)
    print("Bot:", response)

    if "Goodbye" in response:
        break

import re

def chatbot(query):
    query = query.lower()
    movie_name = None

    # Try to find the movie name in the dataset
    for title in movie_info.keys():
        if title in query:
            movie_name = title
            break

    if not movie_name:
        return "Sorry, I couldn‚Äôt find that movie in my database."

    info = movie_info[movie_name]
    response = ""

    # Director questions
    if re.search(r"who (directed|is the director of)", query):
        response = f'The movie "{movie_name.title()}" was directed by {info["director"]}.'

    # Year questions
    elif re.search(r"(when|what year).*released", query):
        response = f'The movie "{movie_name.title()}" was released in {info["year"]}.'

    # Genre questions
    elif re.search(r"(what|tell me).*genre", query):
        response = f'The movie "{movie_name.title()}" belongs to the genres: {info["genre"]}.'

    # IMDb score
    elif re.search(r"(imdb|rating|score)", query):
        response = f'The movie "{movie_name.title()}" has an IMDb score of {info["imdb_score"]}.'

    # Budget
    elif re.search(r"(budget|cost|how much was spent)", query):
        response = f'The estimated budget for "{movie_name.title()}" was ${info["budget"]}.'

    # Language
    elif re.search(r"language", query):
        response = f'The movie "{movie_name.title()}" was made in {info["language"]}.'

    # Country
    elif re.search(r"country|made in", query):
        response = f'"{movie_name.title()}" was produced in {info["country"]}.'

    # Duration
    elif re.search(r"(duration|long|runtime|length)", query):
        response = f'The runtime of "{movie_name.title()}" is approximately {info["duration"]} minutes.'

    else:
        response = f'I know about "{movie_name.title()}" ‚Äî it was directed by {info["director"]} in {info["year"]}, and belongs to the genres: {info["genre"]}.'

    return response

# üé¨ MovieBot Interactive Chat - Final Test Version

print("Hi! I'm MovieBot üé•")
print("Ask me anything about movies ‚Äî like directors, release years, genres, or IMDb ratings.")
print("Type 'bye' to exit.\n")

while True:
    user_input = input("You: ").lower().strip()
    if user_input == "bye":
        print("Bot: Goodbye! üçø Hope you enjoyed chatting about movies.")
        break

    found = False
    for title, info in movie_info.items():
        if title.lower() in user_input:
            # Natural response patterns
            if "director" in user_input:
                print(f'Bot: The movie "{title}" was directed by {info["director"]}.')
            elif "year" in user_input or "release" in user_input:
                print(f'Bot: "{title}" was released in {info["year"]}.')
            elif "genre" in user_input:
                print(f'Bot: The genre of "{title}" is {info["genre"]}.')
            elif "rating" in user_input or "imdb" in user_input:
                print(f'Bot: The IMDb rating for "{title}" is {info["imdb_score"]}.')
            elif "budget" in user_input:
                print(f'Bot: The budget of "{title}" was approximately ${info["budget"]}.')
            elif "language" in user_input:
                print(f'Bot: The language of "{title}" is {info["language"]}.')
            elif "country" in user_input:
                print(f'Bot: "{title}" was produced in {info["country"]}.')
            elif "actor" in user_input:
                print(f'Bot: One of the main actors in "{title}" is {info["actor_1_name"]}.')
            else:
                print(f'Bot: "{title}" was directed by {info["director"]} and released in {info["year"]}.')
            found = True
            break

    if not found:
        print("Bot: Sorry, I couldn‚Äôt find that movie. Try another one?")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import re
# 
# # Load the dataset (use your existing dataset path)
# dataset_path = "/root/.cache/kagglehub/datasets/carolzhangdc/imdb-5000-movie-dataset/versions/1/movie_metadata.csv"
# df = pd.read_csv(dataset_path)
# df.columns = df.columns.str.strip()
# 
# # Create movie info dictionary (same logic as before)
# movie_info = {}
# for _, row in df.iterrows():
#     title = str(row["movie_title"]).strip().lower()
#     movie_info[title] = {
#         "director": row["director_name"],
#         "year": row["title_year"],
#         "genre": row["genres"],
#         "language": row["language"],
#         "country": row["country"],
#         "imdb_score": row["imdb_score"],
#         "duration": row["duration"],
#         "budget": row["budget"],
#         "gross": row["gross"],
#         "actors": [row["actor_1_name"], row["actor_2_name"], row["actor_3_name"]]
#     }
# 
# # --- Streamlit App UI ---
# st.title("üé¨ MovieBot ‚Äì AI Movie Info Assistant")
# st.markdown("Ask me about movies ‚Äî directors, genres, ratings, budgets, languages and more!")
# 
# query = st.text_input("üí≠ Type your question here:")
# 
# def chatbot(query):
#     query = query.lower()
#     movie_name = None
#     for title in movie_info.keys():
#         if title in query:
#             movie_name = title
#             break
# 
#     if not movie_name:
#         return "Sorry, I couldn‚Äôt find that movie in my database."
# 
#     info = movie_info[movie_name]
# 
#     if re.search(r"who (directed|is the director of)", query):
#         return f'The movie "{movie_name.title()}" was directed by {info["director"]}.'
#     elif re.search(r"(when|what year).*released", query):
#         return f'The movie "{movie_name.title()}" was released in {info["year"]}.'
#     elif re.search(r"(what|tell me).*genre", query):
#         return f'The movie "{movie_name.title()}" belongs to the genres: {info["genre"]}.'
#     elif re.search(r"(imdb|rating|score)", query):
#         return f'The movie "{movie_name.title()}" has an IMDb rating of {info["imdb_score"]}.'
#     elif re.search(r"(budget|cost|how much was spent)", query):
#         return f'The budget for "{movie_name.title()}" was approximately ${info["budget"]}.'
#     elif re.search(r"language", query):
#         return f'The movie "{movie_name.title()}" was made in {info["language"]}.'
#     elif re.search(r"country|made in", query):
#         return f'"{movie_name.title()}" was produced in {info["country"]}.'
#     elif re.search(r"(duration|long|runtime|length)", query):
#         return f'The runtime of "{movie_name.title()}" is about {info["duration"]} minutes.'
#     elif re.search(r"(actor|actress|star|cast)", query):
#         return f'The main actors in "{movie_name.title()}" are {", ".join(a for a in info["actors"] if pd.notna(a))}.'
#     else:
#         return f'I know about "{movie_name.title()}" ‚Äî directed by {info["director"]} in {info["year"]}, rated {info["imdb_score"]}, and belongs to genres {info["genre"]}.'
# 
# if query:
#     st.write("üé• **Answer:**", chatbot(query))
#

!pip install streamlit pyngrok -q

from pyngrok import ngrok

# Run Streamlit app
!streamlit run app.py &

# Expose the app via ngrok
public_url = ngrok.connect(8501)
print("üåê Streamlit app is live here:", public_url)

!npm install -g localtunnel
!streamlit run app.py & npx localtunnel --port 8501

# Install localtunnel (do this only once)
!npm install -g localtunnel

# Run Streamlit (in background) and expose it via localtunnel
!streamlit run app.py & npx localtunnel --port 8501

!curl https://loca.lt/mytunnelpassword

!pip install cloudflared

!streamlit run app.py & npx kill-port 8501